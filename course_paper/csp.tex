\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[pdftex,unicode]{hyperref}
\usepackage[margin=15mm,left=2cm]{geometry}
\usepackage{indentfirst}
\usepackage{amsbib}

\sloppy
\clubpenalty=999
\widowpenalty=9999

% This is all for formatting and making the Table of Contents according to 
% spec. Don't play with it.
\makeatletter
\renewcommand\l@section[2]{%
    \ifnum \c@tocdepth >\z@
        \addpenalty\@secpenalty
        \addvspace{1.0em \@plus\p@}%
        \setlength\@tempdima{1.5em}%
        \begingroup
        \parindent \z@ \rightskip \@pnumwidth
        \parfillskip -\@pnumwidth
        \leavevmode \bfseries
        \advance\leftskip\@tempdima
        \hskip -\leftskip
#1\nobreak\ 
        \leaders\hbox{$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}
    \hfil \nobreak\hb@xt@\@pnumwidth{\hss #2}\par
        \endgroup
    \fi}
\makeatother

\title{Верхние оценки параметра treewidth для класса предикатных схем}
\author{Василевская И.\,Ю.}
\date{\today}

\begin{document}
    \begin{titlepage}
        \begin{center}
            Московский Государственный Университет им. Ломоносова\\
            Факультет Вычислительной Математики и Кибернетики\\
            Кафедра Математической Кибернетики\\
            магистратура, отделение <<МММ СБИС>>\\[6cm]

            \large {Василевская Инесса Юрьевна}\\
            \LARGE \textbf {Сведение модели предикатных схем к CSP с булевыми ограничениями}\\[0.8cm]
            \large \emph {Курсовая работа}\\[5.0cm]

            \begin{flushright}
                \large
                \begin{minipage}{0.40\textwidth}
                    \begin{flushleft}
                        \emph{Научный руководитель:}\\к.ф.м.н М.\,С.~Шуплецов
                    \end{flushleft}
                \end{minipage}
            \end{flushright}

            \vfill
            Москва\\
			2012
        \end{center}
    \end{titlepage}

\setcounter{page}{2}

\tableofcontents

\section{Введение}
\label{beginning}
В ряде работ (\cite{Shu09}, \cite{Shu11}) рассматривается задача синтеза для специального класса дискретных управляющих систем ~--
класса предикатных схем, который обобщает некоторые традиционные классы схем. Данные схемы строятся из предикатных элементов
и обладают рядом отличий от схем из других классов (например, направление протекания сигналов не является фиксированным).
Указанные выше работы в основном посвящены исследованию асимптотики функции Шеннона в классе предикатных схем,
 получению асимптотических оценок высокой степени точности и вопросам моделирования предикатными схемами схем из традиционных классов.

В силу особенностей класса предикатных схем, при его рассмотрении могут возникать вопросы,
нетипичные для традиционных классов. Так, к примеру, довольно любопытен вопрос функционирования предикатных схем с точки зрения оценки времени, которое нужно затратить для
вычисления конкретной схемы. 
В данной работе в качестве меры <<быстрой вычислимости>>\footnote{в англоязычной литературе употребляется термин tracktability}
 был выбран так называемый параметр \textit{ширины декомпозиции}\footnote{В англоязычных источниках известного как treewidth}
 ~-- максимального числа вершин в узле дерева, 
которое можно оптимально построить по заданной предикатной схеме. 
Во многих работах (например, \cite{CSP10}, \cite{Gott10}, \cite{Prosc89}) было 
показано, что задачи, которые можно переформулировать в терминах Constraint Satisfaction Problem, 
быстро вычислимы, если ширина декомпозиции графа ограничений \footnote{constraint graph}, построенного по этой задаче,
ограничена сверху константой. 

В данной обзорной работе предлагается рассмотреть задачу функционирования предикатных схем как
частный случай задачи нахождения решения для CSP с булевыми ограничениями. Предлагается при исследовании вопроса
<<быстрой вычислимости>> конкретной схемы в заданном базисе использовать методы и алгоритмы,
широко распространенные в теории CSP,
а именно класс методов, вычислительная сложность которых зависит от структуры графа ограничений.


\section{Основные определения}
Ниже приведены формальные определения используемых в работе понятий.

\subsection{Предикатные схемы}

В настоящей работе определение предикатных схем будет дано по аналогии с \cite{Shu11}.

\textbf{Опредение}.
\textit{Схемой из предикатных элементов} или \textit{предикатной схемой в базисе $\Pi$} назовем помеченный
неориентированный двудольный граф следующей структуры:

\begin{itemize}
\item каждая вершина из первой доли помечена некоторым множеством символов из алфавита X и/или 
множеством символов из алфавита Y. 
Алфавит $X$ соответствует \textit{входным} переменным предиката, а $Y$ ~-- его внутренним переменным, 
т.е. переменным, возникающим непосредственно в процессе вычисления; 

\item каждая вершина второй доли помечена некоторым символом $\pi_i$ из множества $\Pi$ и 
соединена $k$ ребрами, пронумерованными числами $1, ..., k$, с вершинами из первой доли.
\end{itemize}

Вершины из первой доли будем называть \textit{узлами} схемы, а вершины из второй доли ~-- её \textit{предикатными элементами}. 
Узлы схемы, соединенные ребрами с предикатным элементом, будем называть полюсами этого элемента, 
а узлы, соответствующие входным переменным, ~-- полюсами схемы.
При этом считается, что узел является $j$-м полюсом предикатного элемента и соответствует 
его $j$-ой переменной, если соединяющее их ребро имеет номер $j$. Полюс схемы, которому приписано 
более одной входной переменной, называется кратным полюсом этой схемы. 

Будем считать элементарной такую предикатную схему, которая состоит либо из изолированной полюсной вершины, 
либо только из одного предикатного элемента $\pi_i$, $1 < i < k$, где $k$ ~-- число полюсов указанного элемента.

В тех случаях, когда это не вызывает разночтений, 
не будем различать узел схемы и переменную, 
символ которой приписан данной вершине, а также предикатный элемент и сам предикат, отвечающий этому элементу. 
Также, для удобства, в некоторых случаях будем использовать упрощенное описание предикатной схемы, 
опуская пометки дуг и некоторых внутренних вершин. 

\subsection{Функционирование предикатных схем}
Функционирование предикатного элемента с $k$ полюсами задается его характеристической функцией от $k$ переменных, 
связанных с указанными полюсами, и определяется тем, что предикатный элемент находится в допустимом состоянии на тех и 
только тех наборах значений этих переменных, на которых данная функция равна 1. 

Предикатная схема $\Sigma$ находится в допустимом состоянии на заданном наборе значений её полюсных переменных тогда и только тогда, 
когда существует такой набор значений внутренних переменных схемы, на котором все предикатные элементы схемы находятся в допустимых состояниях. 
Если же указанного набора значений внутренних переменных не существует, то считается, что схема находится в недопустимом состоянии на 
заданном наборе значений её полюсных переменных.

Предполагается, что предикатная схема $\Sigma$ реализует предикат $\pi$ от её полюсных переменных, если множество допустимых наборов $\pi$ 
совпадает с множеством тех наборов, на которых $\Sigma$ находится в допустимом состоянии. 
При этом схемы будем называть эквивалентными, если они реализуют равные предикаты. 
Отметим, что элементарная предикатная схема, состоящая из изолированной полюсной вершины, реализует тождественно истинный предикат.
 Будем считать также, что тождественно истинный (соответственно тождественно ложный)
 предикат реализуется любой предикатной схемой без входных полюсов, 
которая имеет непустое (соответственно пустое) множество допустимых состояний.

В общем случае граф предикатной схемы может содержать несколько компонент связности. 
В дальнейшем, будем считать, что схема не содержит компонент связности, 
которые не имеют полюсных узлов и для которых существует хотя бы один допустимый набор, так как такие компоненты не влияют на функционирование схемы.

Суперпозицией двух предикатных схем, не имеющих общих вершин и пометок, 
будем называть их объединение с возможным отождествлением группы полюсов этих схем, 
которое сопровождается приписыванием новой (``объединенной'') вершине либо 
некоторого подмножества переменных данной группы, либо ``новой'' внутренней переменной.
 При этом частными случаями суперпозиции являются следующие операции:
\begin{itemize}
\item переименование полюсной переменной схемы

\item введение фиктивной полюсной переменной схемы

\item проекция или снятие полюсной переменной схемы

\item отождествление двух полюсных переменных схемы
\end{itemize}

\subsection{Шефферов базис}

\textbf{Определение.} Пусть $g(x_1, \ldots, x_n)$ ~-- $n$-местная функция из $E$ в $E$. Если $(r_1, \ldots, r_n)$ ~-- кортеж
точек арности $m$, то под $g(r_1, r_2, \ldots , r_n)$ понимается точка арности $m$, $i$-ая координата которой равна значению
функции $g(x_1, \ldots ,x_n)$ от $i$-ых координат точек $r_1, r_2, \ldots , r_n (i = 1, 2, \ldots, m)$.
Пусть $R$ ~-- некоторое $m$-арное отношение на $E$. Будем говорить, что функция $g(x_1, \ldots , x_n)$
сохраняет отношение $R$ (или что $R$ является инвариантом $g$), если для любого набора $(r_1, \ldots , r_n)$ из $R g(r_1, r_2, \ldots , r_n)$ опять принадлежит $R$.
\cite{Bodnar69}

В работе \cite{Shu11} на основе этого определения вводятся множества:
\begin{enumerate}
\item $T_0$ ~-- множество всех предикатов, являющихся инвариантом константной ФАЛ 0;
\item $T_1$ ~-- множество всех предикатов, являющихся инвариантом константной ФАЛ 1;
\item $S$ ~-- множество всех предикатов, являющихся инвариантом ФАЛ $\overline{x}$;
\item $D$ ~-- множество всех предикатов, являющихся инвариантом произвольной дизъюнкции двух и более переменных;
\item $K$ ~-- множество всех предикатов, являющихся инвариантом произвольной конъюнкции двух и более переменных;
\item $SM$ ~-- множество всех предикатов, являющихся инвариантом всех монотонных самодвойственных ФАЛ;
\item $SL$ ~-- множество всех предикатов, являющихся инвариантом всех линейных самодвойственных ФАЛ;
\end{enumerate}

Там же доказывается следующая теорема.

\textbf{Теорема (Критерий полноты для предикатных схем).} Система из $B$ предикатов является полной $\iff$
она не лежит целиком ни в одном из 7 предполных классов: $T_0, T_1, SM, SL, K, D, S$. \cite{Shu11}

\textbf{Следствие.} $\pi = \{(001), (010), (100)\}  $ ~-- полная система, $\pi$~--- Шефферов предикат.

Ниже приведен пример построения предикатной схемы в Шеффером базисе, реализующей $z=\overline{x \oplus y}$.

\begin{figure}[htb]
\centering
\includegraphics[width=0.4\textwidth]{linear.png}
\caption{$z=\overline{x \oplus y}$ в Шефферовом базисе}
\label{fig:sheff}
\end{figure}

\subsection{Обобщенная задача выполнимости}

\textbf{Определение.}\textit{обобщенная задача выполнимости (CSP)}\footnote{Constraint Satisfaction Problem} 
~--- это тройка $<X,D,C>$, где $X$ ~-- набор переменных, $D$ ~-- область определения (домен допустимых значений), 
а $C$ ~-- набор ограничений. Ограничения имеют вид $<t, R_n>$, где $t$ ~--- кортеж из $n$ переменных множества $X$, 
$R_n$ ~-- заданное на $D$ отношение арности $n$. 
Решением задачи CSP является набор значений переменных $X$, который удовлетворяет всем ограничениям из $C$. 

Так, например, задачу 3-ВЫП можно рассматривать как обобщенную задачу выполнимости над булевым доменом, с 
состоящим лишь из отношений-конъюнкций множеством ограничений.

В ряде работ рассматривалась вычислительная сложность задачи CSP. Несмотря на то, что в общем случае задача CSP
принадлежит классу NP, при введении определенных ограничений на множество $C$ или структуру так называемого
графа ограничений\footnote{constraints graph}, существуют быстрые алгоритмы нахождения решения. 
Так, например, в \cite{Shaeffer78} показано, 
что, в тех случаях, когда множество $C$ имеет определенный вид, существуют полиномиальные алгоритмы нахождения решения.
В данной работе будет внимательно рассмотрен второй подход, связанный с исследованием структурных особенностей 
графа ограничений. 

\subsection{Граф ограничений}
Графическим представлением задачи CSP является граф ограничений. 
Существуют несколько вариантов представления графа ограничений\cite{CSP10}\footnote
{в виде гиперграфа, primal-constraint графа, dual-constraint графа}, однако в
данной работе будет использован dual-constraint граф. Строится он следующим образом: 
\begin{itemize}
\item Каждая вершина графа ограничений соответствует одному ограничению; сама вершина помечается множеством переменных, 
входящих в ограничение.
\item Если множества пометок двух вершин имеют непустое пересечение, то между вершинами проводится ребро, которое помечается 
множеством общих переменных.
\end{itemize}

Часто вместо dual-constraint graph рассматривают join-tree constraint graph(JTCG), который получается из первого удалением 
``дублирующих информацию'' ребер. Пусть между двумя вершинами существует путь, 
в пометки каждого ребра которого входит множество $A$. Тогда ребра, которые лежат на других путях между этими вершинами, 
с множеством пометок в точности $A$, называются ``дублирующими информацию'', и их можно убрать без изменения функционирования. 

В дальнейшем, под графом ограничений будет имется в виду join-tree constraint graph.

На рисунке \ref{fig:constraint_graph} приведены примеры соответствующих графов.

\begin{figure}[htb]
\centering
\includegraphics[width=0.50\textwidth]{constraint_graph.png}
\caption{Представления графа ограничений: а~-- гиперграф, b~-- primal graph, c~-- dual graph, d~-- join-tree }
\label{fig:constraint_graph}
\end{figure}


\subsection{Ширина декомпозиции}
\textbf{Определение.} Пусть $R = (X, D, C)$~--- задача CSP. \textit{Декомпозицией $R$} 
будем называть тройку $< T, X, \Psi >$, где $T = (V, E)$~-- дерево, $\chi$, $\psi$ ~-- 
размечающие функции, ставящие в соответствие каждой вершине $v \subseteq V$ два множества, $\chi(v) \subseteq X$
и $\psi(v) \subseteq C$, что выполняются:
\begin{itemize}
\item Каждому ограничению $R_i \in C$, соответствует как минимум одна вершина $v \in V$,
такая что $R_i \in \phi(v)$, и область определения $R_i \subseteq \chi(v)$.
\item (Свойство связности). 
Каждой переменной $X_i \in X$, соответсвует множество ${v \in V |X_i \in \chi(v)}$, порождающее
связное поддерево дерева $T$. 
\end{itemize}

\textbf{Определение.}
\textit{Шириной декомпозиции $ < T, X, \Psi >$} называется $tw = \max_{v \in V}{|\chi(v)| - 1}$.
Шириной декомпозиции задачи CSP~-- $\min_{all~decompositions}{tw}$.


\textbf{Теорема.} В случае, когда $tw \leq const$, 
решение можно найти за полиномиальное от числа отношений время. \cite{CSP10}

\subsection{Некоторые алгоритмы для решения CSP}
Ниже приведены существующие решения, использующих структуру графа ограничений. Наибольший вклад в сложность этих 
алгоритмов вносит параметр ширины декомпозиции.

В случае, если граф ограничений не имеет циклов, решение может быть получено алгоритмом Acyclic Solving,
схема которого приведена ниже.
\begin{figure}[htb]
\centering
\includegraphics[width=0.8\textwidth]{algo_as.png}
\label{fig:algo_acyclic}
\end{figure}

\textbf{Теорема.} Пусть $r$~-- число отношений в задаче CSP, $l$~-- максимальное количество кортежей в отношении.
Тогда сложность алгоритма Acyclic Solving ~-- $O(r*l^2)$.\cite{CSP10}

В случае, если граф ограничений имеет циклы, от них можно избавиться посредством алгоритма Join-Tree-Clustering. 
Для этого используется представление графа ограничений в виде primal graph.
\begin{figure}[htb]
\centering
\includegraphics[width=0.8\textwidth]{algo_jtc.png}
\label{fig:algo_jtc}
\end{figure}

\textbf{Теорема.} Пусть $n$ ~-- количество переменных в задаче CSP, $r$ ~--- количество отношений, $tw$ ~-- 
ширина декомпозиции этой задачи, $k$ ~-- размерность домена. 
Тогда временная сложность алгоритма JTC составляет $O(r*k^{tw+1})$, а объем используемой памяти ~-- $O(n*k^{tw+1})$.\cite{CSP10}

Там же показано, что результатом применения алгоритма JTC к исходной задаче, граф ограничений которой имеет циклы,
является эквивалентная задача CSP с ацикличным графом ограничений.

\textbf{Теорема.} В обозначениях предыдущей теоремы, временная
сложность нахождения решения путем последовательного применения JTC и Acyclic Solving составляет $O(r*tw*\log{k}*k^{tw+1})$,
использование памяти ~-- $O(n*k^{tw+1})$.\cite{CSP10}

\subsection{Класс внешнепланарных графов}

\textbf{Определение.}
Hеориентированный граф $H$ называется \textit{минором графа} $G$, если $H$
является подграфом графа $G$, или может быть получен из подграфа графа $G$ применением операции реберного стягивания.

\textbf{Определение.}
Граф называется внешнепланарным (1-внешнепланарным), если его можно уложить на плоскости таким образом, 
что все вершины графа будут лежать на внешней неограниченной грани.
\textbf{Определение.}
Граф называется $k$-внешнепланарным, если, посредством удаления вершин с внешней грани, 
можно получить $k-1$-внешнепланарный граф.

\textbf{Теорема (признак внешнепланарности графа).}
Граф $G$ является внешнепланарным $\iff$ $G$ не содержит миноров $K_4$ и $K_{2,3}$\cite{Diestel00}.

\begin{figure}[htb]
\centering
\includegraphics[width=0.50\textwidth]{outerplanar.png}
\caption{Пример 3-внепланарного графа.}
\label{fig:outerplanar_graph}
\end{figure}

\textbf{Теорема.}
Пусть $G$~-- $k$-внепланарный граф. Тогда $tw(G) \leq 3k-1.$\cite{Boedlander96}

\section{Модель предикатных схем как частный случай CSP}
\subsection{Сведение задачи вычисления предикатной схемы к задаче нахождения решения задачи CSP}
Как было отмечено в \S \ref{beginning}, задачу функционирования предикатной схемы можно свести к задаче нахождения решения в CSP. 

Пусть предикатная схема $\Sigma$ имеет $m$ входных переменных $x_1, \ldots , x_m$, 
$k$ внутренних переменных $y_1, \ldots , y_k$ и $n$ предикатных элементов $B = \pi_1, \dots , \pi_n$. 
Тогда, для определения функционирования этой схемы нужно найти допустимые значения внутренних переменных на всех $2^{m}$
наборах входных переменных. 

Нетрудно видеть, что эта задача может быть сведена к задаче CSP $<X, D, C>$ следующим образом:
$X$ = $X \bigcup Y$, $D = [0, 1]$, $C = B$. Аналогично поиску функционирования предикатной схемы, 
будут поставлены $2^m$ задач нахождения решения, перед началом вычисления которых переменные $x_1, \ldots , x_m$ 
во всех ограничениях, их содержащих, будут забиты соответствующими значениями $\alpha_1, \ldots , \alpha_n$.

В обеих моделях, сложность вычислений в худшем случае, при применении алгоритма поиска 
с откатом без памяти, требует $2^m * (2^k)^N$ операций, где $N$ ~-- количество предикатов (ограничений) 
в схеме (графе ограничений).

\subsection{Связь графа предикатной схемы и графа ограничений}

\textbf{Утверждение 1.} Если граф предикатной схемы планарен, то граф ограничений тоже будет планарен.

Это нетрудно показать, приведя алгоритм построения графа ограничений по заданной предикатной схеме. 
Пусть дана предикатная схема, уложенная на плоскости без пересечений. Чтобы построить соответствующий ей граф
ограничений\footnote{Join Tree Constraint Graph}, нужно сделать следующее:
\begin{itemize}
\item Каждой предикатной вершине $\pi_i$, смежной с вершинами-переменными $x_1, ... , x_k$, поставить в соответствие
ограничение $c_i$, определенное на множестве $x_1, ..., x_k$.
\item Если какая-то переменная разделялась лишь двумя предикатами, то в графе ограничений
проводится ребро между соответствующими этим предикатам ограничениями; ребро помечается общей переменной.
\item Если какая-то переменная разделялась более чем двумя предикатами, то эти предикаты соединяются 
реберной цепью, как показано на рисунке \ref{fig:induced_to_constraint}. Ребра помечаются общей переменной.
\end{itemize}

Нетрудно видеть, что, после вышеописанных преобразований, получается планарный join tree constraint graph.

\begin{figure}[htb]
\centering
\includegraphics[width=0.8\textwidth]{transform.png}
\caption{Отображение некоторых подграфов предикатной схемы в подграфы графа ограничений}
\label{fig:induced_to_constraint}
\end{figure}


% Список цитируемой литературы
\clearpage
%\addcontentsline{toc}{section}{Список цитируемой литературы}
\thebibliography{99}
\RBibitem{Shu09}
    \by М.~С.~Шуплецов
    \paper Оценки высокой степени точности для сложности предикатных схем в~некоторых базисах
    \inbook Физико-математические науки
    \serial Уч\"eн. зап. Казан. гос. ун-та. Сер. Физ.-матем. науки
    \yr 2009
    \vol 151
    \issue 2
    \pages 173--184
    \publ Изд-во Казанского ун-та
    \publaddr Казань
    \mathnet{http://mi.mathnet.ru/uzku760}

\bibitem{Shu11}Шуплецов М.С. Методы синтеза и оценки сложности схем, построенных из элементов предикатного типа.

\bibitem{CSP10} Handbook of Constraint Programming, ISBN 9780444527264; 2010 г.

\bibitem{Shaeffer78} Schaefer, Thomas J. (1978). 
``The Complexity of Satisfiability Problems''. STOC 1978. pp. 216–226. doi:10.1145/800133.804350.

\bibitem{Zarank54} Zarankiewicz, K. "On a Problem of P. Turán Concerning Graphs." Fund. Math. 41, 137-145, 1954. 

\bibitem{Prosc89} Arnborg, S.; Proskurowski, A. (1989), 
``Linear time algorithms for NP-hard problems restricted to partial k-trees'',
Discrete Applied Mathematics 23 (1): 11–24, doi:10.1016/0166-218X(89)90031-0.

\bibitem{Gott10} 
Georg Gottlob, Reinhard Pichler, and Fang Wei. 2010. Bounded treewidth as a key to tractability of knowledge representation and reasoning. Artif. Intell. 174, 1 (January 2010), 105-132. DOI=10.1016/j.artint.2009.10.003 http://dx.doi.org/10.1016/j.artint.2009.10.003

\bibitem{Diestel00}
Diestel, Reinhard (2000), Graph Theory, Graduate Texts in Mathematics, 
173, Springer-Verlag, ISBN 0-387-98976-5.

\bibitem{Boedlander96}
H. L. Bodlaender, A linear-time algorithm for finding 
tree-decompositions of small
treewidth, SIAM J. Comput. 25 (1996), 1305–1317

\bibitem{Bodnar69}
В. Г. Боднарчук, Л.А. Калужнин, В.Н. Котов, Б.А. Ромов ``Теория Галуа для Агебр Поста'', Кибернетика, №3, 1969.

\endthebibliography

\end{document}
